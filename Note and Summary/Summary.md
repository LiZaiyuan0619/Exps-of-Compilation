# PPT

## 首先分析一下递归下降的分析举例

```
exp: factor
	| exp '+' factor
	| exp '-' factor
	;
```

这段代码看起来是一种上下文无关文法（Context-Free Grammar，CFG）的一部分，用于描述一种语法结构。在这里，**它似乎定义了一个简单的表达式语法**，其中表达式可以由因子（factor）构成，并且可以通过加法（'+'）或减法（'-'）操作符进行组合。

具体来说，这段代码使用了巴科斯-诺尔范式（Backus-Naur Form，BNF）的一种表示方式。每个竖线（|）表示可选的选择，而分号（;）表示产生式的结束。让我解释一下每一部分的含义：

1. **exp: factor**
   表示一个表达式可以由一个因子构成。这是语法的基础情形。

2. **| exp '+' factor**
   表示一个表达式也可以通过将另一个表达式与一个因子相加而构成。这里的 '+' 是加法操作符。

3. **| exp '-' factor**
   类似地，一个表达式也可以通过将另一个表达式与一个因子相减而构成。这里的 '-' 是减法操作符。

这段代码描述了一个简单的表达式语法，其中可以通过递归地组合表达式和因子来构建更复杂的表达式。这是递归下降语法分析的一种表示方式，用于定义编程语言中的语法规则。

```
factor: term
	| factor '*' term
	| factor '/' term
	;
```

这段代码**继续定义了一个因子（factor）的语法规则**，扩展了对因子的定义。这是一种典型的递归下降语法分析规则，让我解释一下：

1. **factor: term**
   表示一个因子可以由一个术语（term）构成。这是语法的基础情形。

2. **| factor '*' term**
   表示一个因子也可以通过将另一个因子与一个术语相乘而构成。这里的 '*' 是乘法操作符。

3. **| factor '/' term**
   类似地，一个因子也可以通过将另一个因子与一个术语相除而构成。这里的 '/' 是除法操作符。

这样的规则描述了一种数学表达式的语法，其中因子可以是一个单独的术语，或者是通过乘法或除法运算构成的更复杂的因子。这种层次结构可以通过递归地应用规则来构建更复杂的表达式。

总体而言，这些规则是一种简化的算术表达式语法，用于语法分析。在实际编程语言的语法中，类似的规则可以描述更复杂的表达式和语句结构。

```
term: NUMBER
	| '-' term
	;
```

这段代码同样是一种上下文无关文法（Context-Free Grammar，CFG），用于描述一种语法结构，特别是**用于定义一个术语（term）的语法规则。**

让我解释一下这段代码的含义：

1. **term: NUMBER**
   表示一个术语可以由一个数字（NUMBER）构成。这是语法的基础情形。

2. **| '-' term**
   表示一个术语也可以通过在一个术语前面添加负号（'-'）而构成。**这里使用了递归的定义，因为 `term` 出现在了产生式的右侧，形成了一个递归结构。**

这样的规则描述了一种数学表达式的语法，其中术语可以是一个单独的数字，或者是一个带有负号的术语。这是一种简化的表达式语法，常见于语法分析的文法规则中，特别是递归下降语法分析。

## 抽象语法树结点

因为要将所有树节点统一，所以我们需要多一个标志位，结点最多两位运算，叶结点还需保存运算数值

icoding给出了结点的定义

```C
struct _ast{
	int ivalue;
	float fvalue;
	char* svalue;
	node_type nodeType;
	past left;
	past right;
	past if_cond;
	past next;
};
```

## 实验任务：

梳理**rdlex.l、rdparser.c**文件，在VScode中调试运行？？？

学习理解sysy文法

编写sysy.y 文法的递归下降程序

​	1.先写不生成语法树的递归下降程序

​	2.改造上面的程序为生成语法树的程序

​	3.进一步改进词法分析程序、showAst()、main()，使得上面的程序最后可以从命令行读取要分析的程序并且分析结束后打印程序结构

## 实验要求

### PPT要求：

说是要提交这几个文件，但之前又说只提交一份程序和一份报告：

词法分析程序 sysy_lex.l

生成语法树的递归下降程序 rd_all.c  含有全部非终结符对应函数（可选）

生成语法树的递归下降程序 rd_icoding.c  含有icoding平台检查函数（必须）用于在线提交的  sysy.y 中 43～99 的产生式

### icoding要求

上传实验所有源代码及实验报告（这里的源代码是指已经完成，但没有通过下面在线测试的代码）

根据实验所给文法，完成非终结符 CallParams、RelExp、Stmt对应的递归下降函数

```c
past rd_relexp();
past rd_call_paras();
past rd_stmt();
```

其中非终结符 Block 和 ArraySubscripts 对应的递归下降函数已实现，可直接调用，函数的声明如下

```c
past rd_block();
past rd_array_subscripts();
```

接下来是词法分析的设定

```C
// 单词类别
enum yytokentype {
	num_INT = 258,
	num_FLOAT = 259,
	Y_ID = 260,
	...
};

typedef struct _TokenType{
	enum yytokentype token; // 单词类别
	union {
		int		ivalue;
		float   fvalue;
		char*	svalue;
	}attr; // 单词属性
}TokenType;

extern TokenType cur_token;//全局变量，表示当前的单词
TokenType advance(); //读取下一个单词，将其保存于 cur_token 中，同时返回该单词

// 下面两个函数用于可能的回溯处理，即如果有多个分支需要尝试，在尝试语法分析前，可调用get_cur_tok_index获取当前单词的位置，
// 之后在分析时可能会调用若干次advance函数，如果分析失败，则可通过set_cur_tok_index函数重置当前单词的位置。
int get_cur_tok_index(); //所有单词已经读入单词数组中，该函数获取当前单词在数组中的下标
void set_cur_tok_index(int ind); //将 cur_token 设置为下标指定的token值
```

抽象语法树的设定如下：

```C
typedef struct _ast ast;
typedef struct _ast *past;

struct _ast{
   int ivalue;
   float fvalue;
   char* svalue;
   node_type nodeType;
   past left;
   past right;
   past if_cond;
   past next;
};

past newAstNode();// 创建一个结点
past newID(char* value); //创建一个结点，并将结点中的 svalue 设置为 value
past newInt(int value); //创建一个结点，并将结点中的 ivalue 设置为 value
```



# rdlex.l、rdparser.c

## rdlex.l

### 文件内容

这是一个使用Flex（一种词法分析器生成工具）生成的用于识别简单表达式的递归下降文法的Lex文件（后缀为“.l”）。让我解释一下其中的主要部分：

1. **起始部分 `%{ ... %}`：**
   - 在这个部分，你可以定义一些全局变量和宏定义。在这个例子中，定义了一个枚举类型 `yytokentype` 用于表示标记的类型（NUMBER和EOL），以及一个整数变量 `yylval`，它用于保存词法分析器识别的数值。

2. **规则部分 `%% ... %%`：**
   - 在这个部分，定义了词法分析器的规则。每条规则由模式和相应的动作组成。模式指定了要匹配的输入文本，而动作则是在匹配到模式时执行的一些代码。
   - 在这个例子中，有几个简单的规则：
     - `"+" | "-" | "*" | "/" | "q" { return yytext[0]; }`：匹配运算符 `+`, `-`, `*`, `/`, 或者字符 `q`，并返回匹配到的字符作为标记。
     - `[0-9]+ { yylval = atoi(yytext); return NUMBER; }`：匹配一个或多个数字，将其转换为整数并保存到 `yylval` 中，然后返回标记类型 `NUMBER`。
     - `\n { return EOL; }`：匹配换行符，并返回标记类型 `EOL`。
     - `[ \t] { /* ignore whitespace */ }`：匹配空格或制表符，但不执行任何动作，即忽略空白字符。
     - `.`：匹配除换行符外的任何字符，当出现无法识别的字符时，打印错误信息。

3. **用户定义的函数：**
   - `yyerror(char *s)`：用于处理语法错误，打印错误信息并返回 0。
   - `yywrap()`：用于指示词法分析器是否继续解析。在这个例子中，总是返回 1，表示文件结束。

这个例子展示了一个非常简单的词法分析器，用于识别基本的运算符和整数。在实际的编译器中，这仅仅是词法分析的一小部分，通常会与语法分析器和语义分析器等组件一起工作，以构建完整的编译器。

### 那这就是一个简单的Lex文件的框架，请你对各部分内容进行 一定的猜测性的拓展说明，要求贴合“递归下降语法分析”

这个Lex文件看起来是为递归下降语法分析的一部分而设计的。让我对各部分进行一些拓展说明，以更贴合递归下降语法分析的概念：

1. **全局变量和宏定义部分 `%{ ... %}`：**
   - 在递归下降语法分析中，这一部分通常会包含一些用于在不同的递归下降函数之间传递信息的全局变量。例如，可以定义一个表示当前分析的标记类型的全局变量，以及其他一些可能在递归下降过程中需要共享的信息。

```c
%{
#include "parser.h"  // 包含递归下降分析器的头文件

enum yytokentype {
    // 定义标记类型
    NUMBER = 258,
    EOL = 259
};

int yylval;  // 用于保存词法分析器识别的数值
Token current_token;  // 表示当前分析的标记类型
%}
```

2. **规则部分 `%% ... %%`：**
   - 在递归下降语法分析中，这一部分通常会包含用于构建抽象语法树的递归下降规则。每个规则可能对应于语法中的一个非终结符，并且它会递归地调用其他规则以构建语法树的不同部分。

```c
%%
// 一些规则的例子，贴合递归下降的框架
expression: term '+' expression { /* 构建抽象语法树节点表示加法表达式 */ }
          | term '-' expression { /* 构建抽象语法树节点表示减法表达式 */ }
          | term { /* 只有一个项，可能是一个数值或者其他表达式 */ }
          ;

term: factor '*' term { /* 构建抽象语法树节点表示乘法表达式 */ }
    | factor '/' term { /* 构建抽象语法树节点表示除法表达式 */ }
    | factor { /* 只有一个因子，可能是一个数值或者其他表达式 */ }
    ;

factor: NUMBER { /* 构建抽象语法树节点表示数值 */ }
      | '(' expression ')' { /* 递归地处理括号内的表达式 */ }
      ;
%%
```

3. **用户定义的函数：**
   - 在递归下降语法分析中，可能需要一些用户定义的函数来处理语法错误、构建抽象语法树等。这些函数通常会被递归下降规则中的动作调用。

```c
int yyerror(char *s)
{
    fprintf(stderr, "Syntax error: %s\n", s);
    return 0;
}

int yywrap()
{
    // 在递归下降中，通常返回 1 表示文件结束
    return 1;
}
```

这样的拓展更贴合递归下降语法分析的思想，其中递归下降规则用于递归地构建抽象语法树，全局变量用于传递信息，用户定义的函数用于处理错误和其他逻辑。当然，实际的递归下降文法可能更加复杂，具体的拓展会取决于语法规则和编程语言的特定要求。

## rdparser.c

### 在递归下降语法分析中，factor、expr、term通常代表什么？

在递归下降语法分析中，通常会使用类似于 `factor`、`expr`、`term` 这样的非终结符来表示语法规则中的不同部分。它们代表不同的语法结构，通常对应于源代码中的一些基本单元或者表达式。

1. **`factor`：**
   
   - 代表语法规则中的最基本的单元，通常包括标识符、常量、函数调用等。`factor` 可能对应于语法中的最小可识别单元，例如数值、变量、或者括号中的表达式。
   
   ```ebnf
   factor: NUMBER
         | ID
         | '(' expr ')'
         ;
   ```
   
2. **`expr`：**
   - 代表表达式（expression），它可能包括多个项（terms），通过运算符相连。`expr` 通常对应于源代码中的一个表达式，例如赋值语句的右侧或者条件语句的条件表达式。

   ```ebnf
   expr: term '+' expr
        | term '-' expr
        | term
        ;
   ```

3. **`term`：**
   
   - 代表项（term），它可能包括多个因子（factors），通过乘法或除法运算符相连。`term` 通常对应于源代码中的一个项，例如在一个算术表达式中的一部分。
   
   ```ebnf
   term: factor '*' term
        | factor '/' term
        | factor
        ;
   ```

这只是一些通用的例子，实际的语法规则会根据编程语言的语法和语义的不同而有所变化。这些非终结符的定义构成了递归下降语法分析中的规则集，解析器通过递归调用这些规则来构建源代码的抽象语法树。

### expr()

获取factor，判定当前tok是+ OR - ，移进获得下一个量，然后根据符号确定操作

注意：

```C
// exp: factor
//	| exp '+' factor
//	| exp '-' factor
//	;
```

### factor()

类似上面的expr()流程，只是这里是乘除关系

```C
// factor: term
//	| factor '*' term
//	| factor '/' term
//	;
```

### term()

```C
// term: NUMBER
//	| '-' term
//	;
```

**需要GPT分析**：判定是NUMBER或-或“q”(直接退出)

### 抽象语法树的定义

定义本身还有指针，定义抽象语法树的结构：值  点的类型 左右指针

### newAstNode()

开辟新的节点，**memset(node, 0, sizeof(ast));**

这行代码使用了C语言标准库中的 `memset` 函数，其目的是将指定内存区域的内容设置为指定的值。让我们逐步解释这行代码：

```c
memset(node, 0, sizeof(ast));
```

1. **`memset` 函数：**
   ```c
   void *memset(void *s, int c, size_t n);
   ```
   `memset` 函数用于设置一块内存的值。它接受三个参数：
   - `s`：指向要设置的内存块的指针。
   - `c`：要设置的值，以 `unsigned char` 形式传递，但通常用整数表示。
   - `n`：要设置的字节数。

2. **参数解释：**
   - `node`：是一个指针，指向要设置的内存块的起始位置。
   - `0`：是要设置的值，这里是将内存块的内容设置为零。
   - `sizeof(ast)`：是要设置的字节数，这里使用了 `sizeof` 运算符，它返回给定类型或对象的大小（以字节为单位）。

3. **作用：**
   这行代码的作用是将指向 `node` 的内存块的内容全部设置为零。通常，这样的操作用于初始化一个结构体或其他数据结构的实例。在这里，`ast` 是一个类型，`node` 是指向该类型的指针，通过 `memset` 将该指针指向的内存块的内容初始化为零，以确保它的所有成员都被正确初始化。

总的来说，这行代码的目的是在内存中创建一个新的 `ast` 对象（或结构体实例），并将所有成员的值初始化为零。

### newNum(int value)

创建新的抽象语法树节点，设置类型和值

### newExpr(int oper, past left, past right)

这里还是这样，只是多了几个变量填入左右

### astTerm()  astFactor()  astExpr()

类似于实现了上面的内容

### showAst(past node, int nest)

递归式print出来所有内容

### main

无限循环，直到输入的是q表明退出，否则一直移进获取表达式然print

## rdparser1.c

该版本内容只是在main函数上有所区别：**需要GPT来分析**，大致是分析对象是一个文件并且最后使用showAst()

具体来说：

setbuf(stdout, NULL);该行代码使用`setbuf`函数来设置标准输出的缓冲。将第二个参数设置为`NULL`表示禁用输出缓冲。

```C
/*
插入解释setbuf()函数
C 标准库中的一个函数，用于设置文件流的缓冲int setbuf(FILE *stream, char *buf);
该函数用于自定义缓冲区以提高文件的 I/O 性能。具体而言，它允许你将一个用户提供的缓冲区与一个文件流相关联，以便在读取或写入时使用该缓冲区，而不是使用标准库默认的缓冲机制。

stream 参数是一个指向 FILE 结构的指针，表示要设置缓冲区的文件流。
buf 参数是一个指向用于缓冲的数组的指针。如果传递 NULL，则关闭缓冲。
调用 setbuf 函数的主要目的是灵活地控制文件流的缓冲。
*/
```

yyin = fopen("expr.txt", "r");这里打开了一个名为 "expr.txt" 的文件，用于语法分析。`yyin` 可能是一个全局变量，被用作语法分析器的输入文件。

past rr = astExpr();这里调用了 `astExpr` 函数，该函数可能是进行语法分析并返回一个抽象语法树（Abstract Syntax Tree，AST）的函数。`past` 是一个类型，可能是用于表示抽象语法树节点的结构体。

showAst(rr, 0);这里调用了 `showAst` 函数，该函数可能用于在标准输出上显示抽象语法树。第二个参数 `0` 可能是表示缩进级别。

----

## Wave

代码的主体部分是创建各种结点和对应的解析各类表达式

具体来说，我们的创建结点包括：二元操作，声明引用，while、if、break、continue、return，而解析表达式是：加减法、乘除取模、一元、基本、与、或、相等、调参、关系、语句，后者执行递归下降语法分析，根据语法规则来构造AST

**我们先介绍第一大部分：**

二元操作：创建结点，设置结点类型、存储操作符，存储左右操作数

声明引用：创建结点，设置结点类型，存储名称，存储左右子结点

while：创建结点，设置类型，左是条件，右是循环体

if：创建结点，注意这里是if_cond里面是条件，左是if部分，右是else部分

break：创建结点，设置类型是break结束

continue：创建结点，设置类型是continue结束

return：创建结点，设置类型，左右仍然设置，但一般情况下返回一个就是左

**下面是解析表达式部分：**

基本表达式：初始结点设置空，判断当前token，然后分别进入相应处理，这是根据文法，相对较难的是遇到标识符（处理左值）和括号表达式，标识符则获取标识符的字符串值，调用现成的函数解析数组下标，然后构造结点（接收刚才的标识符和数组下标），移进结束；括号表达式则移进，创建结点，判断是否有右括号，右就继续移进

一元表达式：初始结点为基本表达式，基本表达式空就循环，如果是标识符获取字符串值存储到s中，移进，如果是左括号，那这就是函数调用，移进，解析函数调用参数，创建结点返回；如果是加减反就记录符号，移进，获取一元表达式，构造二元操作表达式

加减表达式：当token是加减符时，记录运算符，移进，获取乘法表达式（得到结点表示数字），构造二元表达式

乘除表达式  相等表达式极为类似

关系表达式：一直循环，如果时关系运算符就构建结点并break，不是就返回左

或表达式：获取逻辑与表达式，如果是或就一直循环，记录运算符，移进，获取与运算符，构造二元操作

函数调用参数：使用链表来处理，获取加法表达式，定义头结点，循环：当前符号非逗号时break，移进获取加法表达式，当前的下一个新结点，指针移动到下一个继续循环

各种语句：直接根据当前的token选择进入哪一个（把上面的那一部分给包括进来）：赋值语句、空语句、代码块、while语句、if语句、break、continue、return



实现的递归下降分析程序能够完成对sysy文法中多个部分完成分析并生成AST，满足了icoding要求

个人通过这次实验温习了递归下降文法分析法，亲自实现过程考虑到了许多细节，但是需要明显指出的是：递归下降分析法对含有公共左因子和左递归的文法词法分析效果较差。

此外，为了补充和完善本次实验报告，我将这次实验涉及到的个人代码、笔记、总结内容上传GitHub，网站：[LiZaiyuan0619/Exps-of-Compilation (github.com)](https://github.com/LiZaiyuan0619/Exps-of-Compilation)
